# RGO 性能分析报告

本报告对比了 RGO 库中的 Ruby 风格类（RString、RInteger、RHash、RClass）与原生 Go 对象的性能差异。

## 测试环境

- **操作系统**: Windows
- **架构**: amd64
- **CPU**: AMD Ryzen 9 9950X 16-Core Processor
- **Go 版本**: 最新版本

## 性能对比结果

### 1. RString vs 原生 String

| 操作 | RString | 原生 String | 性能差异 | 内存分配 |
|------|---------|-------------|----------|----------|
| 创建 | 0.18 ns/op | 0.18 ns/op | **相同** | 0 B/op |
| 长度计算 | 10.99 ns/op | 11.25 ns/op | **RString 稍快** | 0 B/op |
| 字符串连接 | 5.94 ns/op | 5.98 ns/op | **相同** | 0 B/op |
| 大写转换 | 24.10 ns/op | 24.00 ns/op | **相同** | 16 B/op |
| 字符串分割 | 104.7 ns/op | 28.46 ns/op | **原生快 3.7x** | 256 vs 64 B/op |
| 字符串替换 | 45.54 ns/op | 45.29 ns/op | **相同** | 32 B/op |
| 复杂操作 | 165.9 ns/op | 107.3 ns/op | **原生快 1.5x** | 168 vs 72 B/op |

**分析**：
- 基本操作（创建、长度、连接、大写转换）性能相当
- 复杂操作（分割、复合操作）原生 String 更快，主要因为 RString 需要额外的对象包装

### 2. RInteger vs 原生 int

| 操作 | RInteger | 原生 int | 性能差异 | 内存分配 |
|------|----------|----------|----------|----------|
| 创建 | 0.18 ns/op | 0.18 ns/op | **相同** | 0 B/op |
| 加法 | 0.18 ns/op | 0.18 ns/op | **相同** | 0 B/op |
| 乘法 | 0.18 ns/op | 0.18 ns/op | **相同** | 0 B/op |
| 幂运算 | 11.01 ns/op | 1.998 ns/op | **原生快 5.5x** | 0 B/op |
| 转字符串 | 11.24 ns/op | 11.21 ns/op | **相同** | 8 B/op |
| 链式操作 | 0.18 ns/op | 0.18 ns/op | **相同** | 0 B/op |
| 复杂操作 | 19.04 ns/op | 10.44 ns/op | **原生快 1.8x** | 3 B/op |

**分析**：
- 基本算术操作性能完全相同，编译器优化效果显著
- 幂运算差异较大，RInteger 使用 math.Pow 而原生使用循环
- 复杂操作中原生 int 更快，主要因为避免了对象创建开销

### 3. RHash vs 原生 map

| 操作 | RHash | 原生 map | 性能差异 | 内存分配 |
|------|-------|----------|----------|----------|
| 创建 | 4.51 ns/op | 4.43 ns/op | **相同** | 0 B/op |
| 设置值 | 10.23 ns/op | 10.13 ns/op | **相同** | 0 B/op |
| 获取值 | 7.89 ns/op | 7.94 ns/op | **相同** | 0 B/op |
| 删除值 | 35.59 ns/op | 28.57 ns/op | **原生快 1.2x** | 0 B/op |
| 合并操作 | 8226 ns/op | 8427 ns/op | **RHash 稍快** | 18536 B/op |
| 获取键列表 | 104466 ns/op | 7380 ns/op | **原生快 14x** | 51981 vs 16384 B/op |

**分析**：
- 基本操作（创建、设置、获取）性能相当
- 获取键列表操作差异巨大，RHash 的排序逻辑导致性能下降
- RHash 在某些复杂操作中内存使用更多

### 4. RClass vs 原生 struct

| 操作 | RClass | 原生 struct | 性能差异 | 内存分配 |
|------|--------|-------------|----------|----------|
| 创建实例 | 13.74 ns/op | 4.52 ns/op | **原生快 3x** | 0 B/op |
| 方法定义 | 373.3 ns/op | 313.5 ns/op | **原生快 1.2x** | 190 vs 120 B/op |
| 方法调用 | 88.51 ns/op | 0.18 ns/op | **原生快 492x** | 40 vs 0 B/op |
| 字段访问 | 31.35 ns/op | 0.18 ns/op | **原生快 174x** | 0 B/op |

**分析**：
- RClass 在所有操作上都明显慢于原生 struct
- 方法调用性能差异最大，反射机制导致巨大开销
- 动态特性带来了显著的性能代价

## 总体性能评估

### 性能等级分类

1. **性能相当** (差异 < 10%)
   - RString: 创建、长度、连接、大写转换、替换
   - RInteger: 创建、基本算术、转字符串、链式操作
   - RHash: 创建、设置、获取、合并

2. **轻微性能损失** (差异 10-50%)
   - RHash: 删除操作
   - RClass: 方法定义

3. **中等性能损失** (差异 50-500%)
   - RString: 分割、复杂操作
   - RInteger: 幂运算、复杂操作
   - RClass: 创建实例

4. **严重性能损失** (差异 > 500%)
   - RHash: 获取键列表
   - RClass: 方法调用、字段访问

### 内存使用分析

- **RString**: 内存使用与原生相当，某些操作略高
- **RInteger**: 内存使用与原生相同
- **RHash**: 某些操作内存使用显著更高
- **RClass**: 动态特性导致额外内存开销

## 性能优化建议

### 1. 针对 RString
- 优化 Split 方法，减少中间对象创建
- 考虑延迟计算策略

### 2. 针对 RInteger
- 优化幂运算实现，考虑使用位运算
- 减少复杂操作中的对象创建

### 3. 针对 RHash
- **重点优化**: Keys() 方法的排序逻辑
- 考虑缓存键列表
- 优化删除操作

### 4. 针对 RClass
- **重点优化**: 方法调用机制
- 考虑编译时优化
- 减少反射使用

## 使用建议

### 适合使用 RGO 的场景
1. **开发效率优先**: 需要 Ruby 风格的链式调用和动态特性
2. **原型开发**: 快速验证想法，性能要求不高
3. **脚本化任务**: 一次性任务，可读性比性能更重要
4. **基本操作**: 简单的字符串和数值操作

### 建议使用原生 Go 的场景
1. **性能关键**: 高频调用、大数据处理
2. **生产环境**: 对性能和内存使用有严格要求
3. **系统编程**: 底层操作、网络编程
4. **复杂数据操作**: 大量的 map 操作、复杂的对象操作

## 结论

RGO 库成功提供了 Ruby 风格的 API，在基本操作上性能损失很小，但在复杂操作和动态特性上存在显著的性能开销。选择使用时需要在开发效率和运行性能之间做出权衡。

**性能损失主要来源**：
1. 对象包装开销
2. 反射机制
3. 动态方法调用
4. 额外的内存分配

**优化潜力**：
- RString 和 RInteger 有较大优化空间
- RHash 的 Keys 方法需要重点优化
- RClass 的动态特性是性能瓶颈，但也是核心价值所在
